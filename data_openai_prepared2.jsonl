{"prompt":"RibbonV2 doesn't lose 90% of its TVL. This test checks that the asset balance of the T-ETH-C and T-WBTC-C vaults don't drop by 90% since the date this test was deployed (2022-03-25). The test failed due to an unforeseen edge case (postmortem coming soon).\n\nContract to be tested:\n\/\/ SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.8;\n\nimport '.\/UpgradeabilityProxy.sol';\n\n\/**\n * @title AdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum\/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n *\/\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\n  \/**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param admin_ Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https:\/\/solidity.readthedocs.io\/en\/v0.4.24\/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   *\/\n  constructor(address _logic, address admin_, bytes memory _data) UpgradeabilityProxy(_logic, _data) payable {\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(admin_);\n  }\n\n  \/**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   *\/\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  \/**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   *\/\n\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  \/**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   *\/\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  \/**\n   * @return adminAddress The address of the proxy admin.\n   *\/\n  function admin() external ifAdmin returns (address adminAddress) {\n    return _admin();\n  }\n\n  \/**\n   * @return implementationAddress The address of the implementation.\n   *\/\n  function implementation() external ifAdmin returns (address implementationAddress) {\n    return _implementation();\n  }\n\n  \/**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   *\/\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  \/**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   *\/\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  \/**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https:\/\/solidity.readthedocs.io\/en\/v0.4.24\/abi-spec.html#function-selector-and-argument-encoding.\n   *\/\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    (bool success,) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  \/**\n   * @return adm The admin slot.\n   *\/\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  \/**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   *\/\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  \/**\n   * @dev Only fall back when the sender is not the admin.\n   *\/\n  function _willFallback() internal override virtual {\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n    super._willFallback();\n  }\n}","completion":" GPL-3.0-only\n\n\/\/ ┏━━━┓━━━━━┏┓━━━━━━━━━┏━━━┓━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ┃┏━┓┃━━━━┏┛┗┓━━━━━━━━┃┏━━┛━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ┃┗━┛┃┏━┓━┗┓┏┛┏━━┓━━━━┃┗━━┓┏┓┏━┓━┏━━┓━┏━┓━┏━━┓┏━━┓\n\/\/ ┃┏━┓┃┃┏┓┓━┃┃━┃┏┓┃━━━━┃┏━━┛┣┫┃┏┓┓┗━┓┃━┃┏┓┓┃┏━┛┃┏┓┃\n\/\/ ┃┃ ┃┃┃┃┃┃━┃┗┓┃┃━┫━┏┓━┃┃━━━┃┃┃┃┃┃┃┗┛┗┓┃┃┃┃┃┗━┓┃┃━┫\n\/\/ ┗┛ ┗┛┗┛┗┛━┗━┛┗━━┛━┗┛━┗┛━━━┗┛┗┛┗┛┗━━━┛┗┛┗┛┗━━┛┗━━┛\n\/\/ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\npragma solidity ^0.8.0;\n\nimport {AnteTest} from \"..\/AnteTest.sol\";\nimport {IRibbonThetaVault} from \".\/ribbon-v2-contracts\/interfaces\/IRibbonThetaVault.sol\";\nimport {IController, GammaTypes} from \".\/ribbon-v2-contracts\/interfaces\/GammaInterface.sol\";\nimport {Vault} from \".\/ribbon-v2-contracts\/libraries\/Vault.sol\";\nimport {IERC20} from \"@openzeppelin\/contracts\/token\/ERC20\/IERC20.sol\";\n\n\/\/\/ @title Checks that RibbonV2 Theta vaults do not lose 90% of their assets\n\/\/\/ @notice Ante Test to check if a catastrophic failure has occured in RibbonV2\ncontract AnteRibbonV2ThetaVaultPlungeTest is AnteTest(\"RibbonV2 doesn't lose 90% of its TVL\") {\n    \/\/ currently deployed RibbonV2 theta vaults\n    IRibbonThetaVault[2] public thetaVaults = [\n        IRibbonThetaVault(0x25751853Eab4D0eB3652B5eB6ecB102A2789644B), \/\/ eth vault\n        IRibbonThetaVault(0x65a833afDc250D9d38f8CD9bC2B1E3132dB13B2F) \/\/ wbtc vault\n    ];\n\n    \/\/ Opyn Controller\n    IController internal controller = IController(0x4ccc2339F87F6c59c6893E1A678c2266cA58dC72);\n\n    \/\/ threshold amounts for test to fail\n    uint256[2] public thresholds;\n\n    \/\/\/ @notice percent drop threshold (set to 10%)\n    uint8 public constant PERCENT_DROP_THRESHOLD = 10;\n\n    constructor() {\n        protocolName = \"Ribbon\";\n        for (uint256 i; i < thetaVaults.length; i++) {\n            thresholds[i] = (calculateAssetBalance(thetaVaults[i]) * PERCENT_DROP_THRESHOLD) \/ 100;\n            testedContracts.push(address(thetaVaults[i]));\n        }\n    }\n\n    \/\/\/ @notice computes balance of underlying asset in a given Ribbon Theta Vault\n    \/\/\/ @param vault RibbonV2 Theta Vault address\n    \/\/\/ @return balance of vault\n    function calculateAssetBalance(IRibbonThetaVault vault) public view returns (uint256) {\n        Vault.VaultParams memory vaultParams = vault.vaultParams();\n        IERC20 underlying = IERC20(vaultParams.underlying);\n\n        GammaTypes.Vault memory opynVault = controller.getVault(\n            address(vault),\n            controller.getAccountVaultCounter(address(vault))\n        );\n\n        \/\/ make assumption that there is only one collateral asset in vault\n        return underlying.balanceOf(address(vault)) + opynVault.collateralAmounts[0];\n    }\n\n    \/\/\/ @notice checks balance of Ribbon Theta V2 vaults against threshold\n    \/\/\/ (10% of balance when this contract was deployed)\n    \/\/\/ @return true if balance of all theta vaults is greater than thresholds\n    function checkTestPasses() external view override returns (bool) {\n        for (uint256 i; i < thetaVaults.length; i++) {\n            if (calculateAssetBalance(thetaVaults[i]) < thresholds[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n} END"}
{"prompt":"Ante test states are synchronized. Checks that all pools linked to an Ante Test share the same pass\/fail state\n\n\n\nContract to be tested:\n\/\/ SPDX-License-Identifier: GPL-3.0-only\n\n\/\/ ┏━━━┓━━━━━┏┓━━━━━━━━━┏━━━┓━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ┃┏━┓┃━━━━┏┛┗┓━━━━━━━━┃┏━━┛━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ┃┗━┛┃┏━┓━┗┓┏┛┏━━┓━━━━┃┗━━┓┏┓┏━┓━┏━━┓━┏━┓━┏━━┓┏━━┓\n\/\/ ┃┏━┓┃┃┏┓┓━┃┃━┃┏┓┃━━━━┃┏━━┛┣┫┃┏┓┓┗━┓┃━┃┏┓┓┃┏━┛┃┏┓┃\n\/\/ ┃┃ ┃┃┃┃┃┃━┃┗┓┃┃━┫━┏┓━┃┃━━━┃┃┃┃┃┃┃┗┛┗┓┃┃┃┃┃┗━┓┃┃━┫\n\/\/ ┗┛ ┗┛┗┛┗┛━┗━┛┗━━┛━┗┛━┗┛━━━┗┛┗┛┗┛┗━━━┛┗┛┗┛┗━━┛┗━━┛\n\/\/ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\npragma solidity ^0.8.0;\n\nimport \".\/AntePool.sol\";\nimport \".\/interfaces\/IAnteTest.sol\";\nimport \".\/interfaces\/IAntePool.sol\";\nimport \".\/interfaces\/IAntePoolFactory.sol\";\nimport \".\/interfaces\/IAntePoolFactoryController.sol\";\nimport \"@openzeppelin\/contracts\/security\/ReentrancyGuard.sol\";\n\n\/\/\/ @title Ante V0.6 Ante Pool Factory smart contract\n\/\/\/ @notice Contract that creates an AntePool wrapper for an AnteTest\ncontract AntePoolFactory is IAntePoolFactory, ReentrancyGuard {\n    struct TestStateInfo {\n        bool hasFailed;\n        address verifier;\n        uint256 failedBlock;\n        uint256 failedTimestamp;\n    }\n\n    mapping(address => TestStateInfo) private stateByTest;\n\n    \/\/ Stores all the pools associated with a test\n    mapping(address => address[]) public poolsByTest;\n    \/\/\/ @inheritdoc IAntePoolFactory\n    mapping(bytes32 => address) public override poolByConfig;\n    \/\/\/ @inheritdoc IAntePoolFactory\n    address[] public override allPools;\n\n    \/\/\/ @dev The maximum number of pools allowed to be created for an Ante Test\n    uint256 public constant MAX_POOLS_PER_TEST = 10;\n\n    \/\/\/ @inheritdoc IAntePoolFactory\n    IAntePoolFactoryController public override controller;\n\n    \/\/\/ @param _controller The address of the Ante Factory Controller\n    constructor(address _controller) {\n        controller = IAntePoolFactoryController(_controller);\n    }\n\n    \/\/\/ @inheritdoc IAntePoolFactory\n    function createPool(\n        address testAddr,\n        address tokenAddr,\n        uint256 payoutRatio,\n        uint256 decayRate,\n        uint256 authorRewardRate\n    ) external override returns (address testPool) {\n        \/\/ Checks that a non-zero AnteTest address is passed in and that\n        \/\/ an AntePool has not already been created for that AnteTest\n        require(testAddr != address(0), \"ANTE: Test address is 0\");\n        require(!stateByTest[testAddr].hasFailed, \"ANTE: Test has previously failed\");\n        require(controller.isTokenAllowed(tokenAddr), \"ANTE: Token not allowed\");\n        require(poolsByTest[testAddr].length < MAX_POOLS_PER_TEST, \"ANTE: Max pools per test reached\");\n\n        uint256 tokenMinimum = controller.getTokenMinimum(tokenAddr);\n        bytes32 configHash = keccak256(\n            abi.encodePacked(testAddr, tokenAddr, tokenMinimum, payoutRatio, decayRate, authorRewardRate)\n        );\n        address poolAddr = poolByConfig[configHash];\n        require(poolAddr == address(0), \"ANTE: Pool with the same config already exists\");\n\n        IAnteTest anteTest = IAnteTest(testAddr);\n\n        testPool = address(new AntePool{salt: configHash}(controller.antePoolLogicAddr()));\n\n        require(testPool != address(0), \"ANTE: Pool creation failed\");\n\n        poolsByTest[testAddr].push(testPool);\n        poolByConfig[configHash] = testPool;\n        allPools.push(testPool);\n\n        IAntePool(testPool).initialize(\n            anteTest,\n            IERC20(tokenAddr),\n            tokenMinimum,\n            decayRate,\n            payoutRatio,\n            authorRewardRate\n        );\n\n        emit AntePoolCreated(\n            testAddr,\n            tokenAddr,\n            tokenMinimum,\n            payoutRatio,\n            decayRate,\n            authorRewardRate,\n            testPool,\n            msg.sender\n        );\n    }\n\n    \/\/\/ @inheritdoc IAntePoolFactory\n    function hasTestFailed(address testAddr) external view override returns (bool) {\n        return stateByTest[testAddr].hasFailed;\n    }\n\n    \/\/\/ @inheritdoc IAntePoolFactory\n    function checkTestWithState(\n        bytes memory _testState,\n        address verifier,\n        bytes32 poolConfig\n    ) public override nonReentrant {\n        address poolAddr = poolByConfig[poolConfig];\n        require(poolAddr == msg.sender, \"ANTE: Must be called by a pool\");\n\n        IAntePool pool = IAntePool(msg.sender);\n        (, , uint256 claimableShares, ) = pool.getChallengerInfo(verifier);\n        require(claimableShares > 0, \"ANTE: Only confirmed challengers can checkTest\");\n        require(\n            pool.getCheckTestAllowedBlock(verifier) < block.number,\n            \"ANTE: must wait 12 blocks after challenging to call checkTest\"\n        );\n        IAnteTest anteTest = pool.anteTest();\n        bool hasFailed = stateByTest[address(anteTest)].hasFailed;\n        require(!hasFailed, \"ANTE: Test already failed.\");\n\n        pool.updateVerifiedState(verifier);\n        if (!_checkTestNoRevert(anteTest, _testState)) {\n            _setFailureStateForTest(address(anteTest), verifier);\n        }\n    }\n\n    \/\/\/ @inheritdoc IAntePoolFactory\n    function getPoolsByTest(address testAddr) external view override returns (address[] memory) {\n        return poolsByTest[testAddr];\n    }\n\n    \/\/\/ @inheritdoc IAntePoolFactory\n    function getNumPoolsByTest(address testAddr) external view override returns (uint256) {\n        return poolsByTest[testAddr].length;\n    }\n\n    \/\/\/ @inheritdoc IAntePoolFactory\n    function numPools() external view override returns (uint256) {\n        return allPools.length;\n    }\n\n    \/*****************************************************\n     * =============== INTERNAL HELPERS ================ *\n     *****************************************************\/\n\n    \/\/\/ @notice Checks the connected Ante Test, also returns true if\n    \/\/\/ setStateAndCheckTestPasses or checkTestPasses reverts\n    \/\/\/ @return passes bool if the Ante Test passed\n    function _checkTestNoRevert(IAnteTest anteTest, bytes memory _testState) internal returns (bool) {\n        \/\/ This condition replicates the logic from AnteTest(v0.6).setStateAndCheckTestPasses\n        \/\/ It is used for backward compatibility with v0.5 tests\n        if (_testState.length > 0) {\n            try anteTest.setStateAndCheckTestPasses(_testState) returns (bool passes) {\n                return passes;\n            } catch {\n                return true;\n            }\n        }\n\n        try anteTest.checkTestPasses() returns (bool passes) {\n            return passes;\n        } catch {\n            return true;\n        }\n    }\n\n    function _setFailureStateForTest(address testAddr, address verifier) internal {\n        TestStateInfo storage testState = stateByTest[testAddr];\n        testState.hasFailed = true;\n        testState.failedBlock = block.number;\n        testState.failedTimestamp = block.timestamp;\n        testState.verifier = verifier;\n\n        address[] memory pools = poolsByTest[testAddr];\n        uint256 numPoolsByTest = pools.length;\n        for (uint256 i = 0; i < numPoolsByTest; i++) {\n            try IAntePool(pools[i]).updateFailureState(verifier) {} catch {\n                emit PoolFailureReverted();\n            }\n        }\n    }\n}","completion":" GPL-3.0-only\n\n\/\/ ┏━━━┓━━━━━┏┓━━━━━━━━━┏━━━┓━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ┃┏━┓┃━━━━┏┛┗┓━━━━━━━━┃┏━━┛━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ┃┗━┛┃┏━┓━┗┓┏┛┏━━┓━━━━┃┗━━┓┏┓┏━┓━┏━━┓━┏━┓━┏━━┓┏━━┓\n\/\/ ┃┏━┓┃┃┏┓┓━┃┃━┃┏┓┃━━━━┃┏━━┛┣┫┃┏┓┓┗━┓┃━┃┏┓┓┃┏━┛┃┏┓┃\n\/\/ ┃┃ ┃┃┃┃┃┃━┃┗┓┃┃━┫━┏┓━┃┃━━━┃┃┃┃┃┃┃┗┛┗┓┃┃┃┃┃┗━┓┃┃━┫\n\/\/ ┗┛ ┗┛┗┛┗┛━┗━┛┗━━┛━┗┛━┗┛━━━┗┛┗┛┗┛┗━━━┛┗┛┗┛┗━━┛┗━━┛\n\/\/ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\npragma solidity ^0.8.0;\n\nimport \"..\/libraries\/ante-v06-core\/AnteTest.sol\";\nimport \"..\/libraries\/ante-v06-core\/interfaces\/IAntePool.sol\";\nimport \"..\/libraries\/ante-v06-core\/interfaces\/IAntePoolFactory.sol\";\n\n\/\/not exposed so we just copy\nstruct TestStateInfo {\n    bool hasFailed;\n    address verifier;\n    uint256 failedBlock;\n    uint256 failedTimestamp;\n}\n\n\n\/\/\/ @title Ante's test states are synchronized\n\/\/\/ @notice Ante Test to check that each pool for a given test have failedBlock and failedTimestamp synchronized with the factory's TestStateInfo\ncontract AnteFailedTestSynchronized is AnteTest(\"Ante test states are synchronized\") {\n    address public immutable factoryContractAddr;\n\n    address private testAddr = address(0);\n\n    \/\/\/ @param _factoryContractAddr Ante factory address\n    constructor(address _factoryContractAddr) {\n        protocolName = \"Ante\";\n        factoryContractAddr = _factoryContractAddr;\n        testedContracts = [factoryContractAddr];\n    }\n\n    function checkTestPasses() public view override returns (bool) {\n        IAntePoolFactory factory = IAntePoolFactory(factoryContractAddr);\n        require(factory.getPoolsByTest(testAddr).length > 0, \"ANTE: testAddr is not a registered test\"); \/\/ must have at least 1 pool\n\n        bool testHasFailed = factory.hasTestFailed(testAddr);\n        address[] memory pools = factory.getPoolsByTest(testAddr);\n\n        for (uint i = 0; i < pools.length; i += 1) { \/\/ capped at MAX_POOLS_PER_TEST=10 so gas bombing shouldn't be a problem\n            IAntePool pool = IAntePool(pools[i]);\n            if (testHasFailed && pool.failedBlock() == 0) return false;\n            if (testHasFailed && pool.failedTimestamp() == 0) return false;\n        }\n\n        return true;\n    }\n    \/\/\/ @param data the state passed by checkTestWithState\n    function _setState(bytes memory data) internal override virtual {\n        testAddr = abi.decode(data, (address));\n    }\n\n    function getStateTypes() external pure override returns (string memory) {\n        return \"address\";\n    }\n\n    function getStateNames() external pure override returns (string memory) {\n        return \"testAddr\";\n    }\n} END"}
{"prompt":"Ensure that a MetaStreet Vault's Junior Tranche is solvent. Checks that realized value is greater than pending redemptions for the junior tranche of the MetaStreet Avatar-DAI vault\n\n\n\nContract to be tested:\n\/\/ SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \".\/IBeacon.sol\";\nimport \"..\/Proxy.sol\";\nimport \"..\/ERC1967\/ERC1967Upgrade.sol\";\n\n\/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n *\/\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    \/**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     *\/\n    constructor(address beacon, bytes memory data) payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    \/**\n     * @dev Returns the current beacon address.\n     *\/\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    \/**\n     * @dev Returns the current implementation address of the associated beacon.\n     *\/\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    \/**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     *\/\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}","completion":" MIT\n\npragma solidity ^0.8.0;\n\nimport \"..\/AnteTest.sol\";\n\ninterface IVaultAbridged {\n    enum TrancheId {\n        Senior,\n        Junior\n    }\n\n    function trancheState(TrancheId trancheId)\n        external\n        view\n        returns (\n            uint256 realizedValue,\n            uint256 estimatedValue,\n            uint256 pendingRedemptions,\n            uint256 redemptionQueue,\n            uint256 processedRedemptionQueue,\n            uint256 depositSharePrice,\n            uint256 redemptionSharePrice_\n        );\n}\n\n\/\/ @title MetaStreet Vault Junior Tranche Solvency Test\n\/\/ @notice Ante Test to check if a MetaStreet Vault's junior tranche is solvent\ncontract AnteMetaStreetVaultSolvencyTest is AnteTest(\"Ensure that a MetaStreet Vault's Junior Tranche is solvent\") {\n    IVaultAbridged private vault;\n\n    constructor(address _vault) {\n        protocolName = \"MetaStreet\";\n        testedContracts.push(_vault);\n\n        vault = IVaultAbridged(_vault);\n    }\n\n    \/\/ @notice Check if a Vault's junior tranche is solvent\n    \/\/ @return true if Vault's junior tranche is solvent, otherwise false\n    function checkTestPasses() external view override returns (bool) {\n        (uint256 realizedValue, , uint256 pendingRedemptions, , , , ) = vault.trancheState(\n            IVaultAbridged.TrancheId.Junior\n        );\n\n        return realizedValue >= pendingRedemptions;\n    }\n}\n END"}
{"prompt":"MetaStreet General-WETH Vault's Junior Tranche is solvent. Checks that realized value is greater than pending redemptions for the junior tranche of the MetaStreet General-WETH vault\n\n\n\nContract to be tested:\n\/\/ SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \".\/IBeacon.sol\";\nimport \"..\/Proxy.sol\";\nimport \"..\/ERC1967\/ERC1967Upgrade.sol\";\n\n\/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n *\/\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    \/**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     *\/\n    constructor(address beacon, bytes memory data) payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    \/**\n     * @dev Returns the current beacon address.\n     *\/\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    \/**\n     * @dev Returns the current implementation address of the associated beacon.\n     *\/\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    \/**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     *\/\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}","completion":" MIT\n\npragma solidity ^0.8.0;\n\nimport \"..\/AnteTest.sol\";\n\ninterface IVaultAbridged {\n    enum TrancheId {\n        Senior,\n        Junior\n    }\n\n    function trancheState(TrancheId trancheId)\n        external\n        view\n        returns (\n            uint256 realizedValue,\n            uint256 estimatedValue,\n            uint256 pendingRedemptions,\n            uint256 redemptionQueue,\n            uint256 processedRedemptionQueue,\n            uint256 depositSharePrice,\n            uint256 redemptionSharePrice_\n        );\n}\n\n\/\/ @title MetaStreet Vault Junior Tranche Solvency Test\n\/\/ @notice Ante Test to check if a MetaStreet Vault's junior tranche is solvent\ncontract AnteMetaStreetVaultSolvencyTest is AnteTest(\"MetaStreet General-WETH Vault's Junior Tranche is solvent\") {\n    IVaultAbridged private vault;\n\n    constructor(address _vault) {\n        protocolName = \"MetaStreet\";\n        testedContracts.push(_vault);\n\n        vault = IVaultAbridged(_vault);\n    }\n\n    \/\/ @notice Check if a Vault's junior tranche is solvent\n    \/\/ @return true if Vault's junior tranche is solvent, otherwise false\n    function checkTestPasses() external view override returns (bool) {\n        (uint256 realizedValue, , uint256 pendingRedemptions, , , , ) = vault.trancheState(\n            IVaultAbridged.TrancheId.Junior\n        );\n\n        return realizedValue >= pendingRedemptions;\n    }\n} END"}
{"prompt":"LlamaPay never pays future payments early (lastPayerUpdate[anyone] <= block.timestamp)\n\nContract to be tested:\n\/\/SPDX-License-Identifier: None\npragma solidity ^0.8.0;\n\nimport {LlamaPay} from \".\/LlamaPay.sol\";\n\n\ncontract LlamaPayFactory {\n    bytes32 constant INIT_CODEHASH = keccak256(type(LlamaPay).creationCode);\n\n    address public parameter;\n    uint256 public getLlamaPayContractCount;\n    address[1000000000] public getLlamaPayContractByIndex; \/\/ 1 billion indices\n\n    event LlamaPayCreated(address token, address llamaPay);\n\n    \/**\n        @notice Create a new Llama Pay Streaming instance for `_token`\n        @dev Instances are created deterministically via CREATE2 and duplicate\n            instances will cause a revert\n        @param _token The ERC20 token address for which a Llama Pay contract should be deployed\n        @return llamaPayContract The address of the newly created Llama Pay contract\n      *\/\n    function createLlamaPayContract(address _token) external returns (address llamaPayContract) {\n        \/\/ set the parameter storage slot so the contract can query it\n        parameter = _token;\n        \/\/ use CREATE2 so we can get a deterministic address based on the token\n        llamaPayContract = address(new LlamaPay{salt: bytes32(uint256(uint160(_token)))}());\n        \/\/ CREATE2 can return address(0), add a check to verify this isn't the case\n        \/\/ See: https:\/\/eips.ethereum.org\/EIPS\/eip-1014\n        require(llamaPayContract != address(0));\n\n        \/\/ Append the new contract address to the array of deployed contracts\n        uint256 index = getLlamaPayContractCount;\n        getLlamaPayContractByIndex[index] = llamaPayContract;\n        unchecked{\n            getLlamaPayContractCount = index + 1;\n        }\n\n        emit LlamaPayCreated(_token, llamaPayContract);\n    }\n\n    \/**\n      @notice Query the address of the Llama Pay contract for `_token` and whether it is deployed\n      @param _token An ERC20 token address\n      @return predictedAddress The deterministic address where the llama pay contract will be deployed for `_token`\n      @return isDeployed Boolean denoting whether the contract is currently deployed\n      *\/\n    function getLlamaPayContractByToken(address _token) external view returns(address predictedAddress, bool isDeployed){\n        predictedAddress = address(uint160(uint256(keccak256(abi.encodePacked(\n            bytes1(0xff),\n            address(this),\n            bytes32(uint256(uint160(_token))),\n            INIT_CODEHASH\n        )))));\n        isDeployed = predictedAddress.code.length != 0;\n    }\n}","completion":" GPL-3.0-only\n\n\/\/ ┏━━━┓━━━━━┏┓━━━━━━━━━┏━━━┓━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ┃┏━┓┃━━━━┏┛┗┓━━━━━━━━┃┏━━┛━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ┃┗━┛┃┏━┓━┗┓┏┛┏━━┓━━━━┃┗━━┓┏┓┏━┓━┏━━┓━┏━┓━┏━━┓┏━━┓\n\/\/ ┃┏━┓┃┃┏┓┓━┃┃━┃┏┓┃━━━━┃┏━━┛┣┫┃┏┓┓┗━┓┃━┃┏┓┓┃┏━┛┃┏┓┃\n\/\/ ┃┃ ┃┃┃┃┃┃━┃┗┓┃┃━┫━┏┓━┃┃━━━┃┃┃┃┃┃┃┗┛┗┓┃┃┃┃┃┗━┓┃┃━┫\n\/\/ ┗┛ ┗┛┗┛┗┛━┗━┛┗━━┛━┗┛━┗┛━━━┗┛┗┛┗┛┗━━━┛┗┛┗┛┗━━┛┗━━┛\n\/\/ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n\/\/ Uses the setTokenAddress and setPayerAddress functions to set the addresses\n\/\/ of the LlamaPay instance(s) and payer address to check\n\/\/ https:\/\/.etherscan.io\/address\/[CONTRACT_ADDRESS]#readContract to check values\n\/\/ https:\/\/.etherscan.io\/address\/[CONTRACT_ADDRESS]#writeContract to set values\n\n\/\/ NOTE: As of May 2022, a challenger attempting to check this test via web app\n\/\/ or interacting with the AntePool directly can potentially be front-run. In\n\/\/ order to avoid being front-run, a potential challenger should deploy an\n\/\/ instance of the AnteLlamaPayTestChallengerWrapper.sol contract and use that\n\/\/ to challenge the Ante Pool. Staking functions can be done normally through\n\/\/ the web app or directly interacting with the AntePool contract.\n\/\/ https:\/\/github.com\/antefinance\/ante-community-tests\/blob\/main\/contracts\/llamapay\/AnteLlamaPayTestChallengerWrapper.sol\n\npragma solidity ^0.7.0;\n\nimport \"..\/libraries\/ante-v05-core\/AnteTest.sol\";\n\ninterface ILlamaPayFactory {\n    function getLlamaPayContractByToken(address _token) external view returns (address, bool);\n}\n\ninterface ILlamaPay {\n    function payers(address _payer) external view returns (uint40, uint216);\n}\n\n\/\/\/ @title  LlamaPay never goes backwards in time test\n\/\/\/ @notice Ante Test to check that lastPayerUpdate <= block.timestamp holds\n\/\/\/         for any LlamaPay payer\/token. Uses the setter functions provided to\n\/\/\/         set the LlamaPay instance and payer to check.\n\/\/\/         Note: may no longer hold after 231,800 A.D. due to holding timestamp in uint40\ncontract AnteLlamaPayTest is\n    AnteTest(\"LlamaPay never pays future payments early (lastPayerUpdate[anyone] <= block.timestamp)\")\n{\n    \/\/ https:\/\/etherscan.io\/address\/0xde1C04855c2828431ba637675B6929A684f84C7F on Eth Mainnet\n    ILlamaPayFactory internal factory;\n\n    address public tokenAddress;\n    address public payerAddress;\n\n    constructor(address _llamaPayFactoryAddress) {\n        factory = ILlamaPayFactory(_llamaPayFactoryAddress);\n\n        protocolName = \"LlamaPay\"; \/\/ <3\n        testedContracts.push(_llamaPayFactoryAddress);\n        testedContracts.push(address(0)); \/\/ LlamaPay instance once set\n    }\n\n    \/\/\/ @notice Checks that lastPayerUpdate[payer] <= block.timestamp for a\n    \/\/\/         given payer and LlamaPay instance. Uses the setter functions\n    \/\/\/         provided to set the token address and payer address to check.\n    \/\/\/ @return true if lastPayerUpdate[payer] <= block.timestamp for the\n    \/\/\/         LlamaPay instance and payer checked\n    function checkTestPasses() external view override returns (bool) {\n        \/\/ If a valid LlamaPay instance is specified, check it\n        (address predictedAddress, bool isDeployed) = factory.getLlamaPayContractByToken(tokenAddress);\n        if (isDeployed) {\n            (uint40 lastPayerUpdate, ) = ILlamaPay(predictedAddress).payers(payerAddress);\n\n            \/\/ We don't need to worry about checking if the payer exists in the\n            \/\/ payer mapping for this LlamaPay instance since 0 < block.timestamp\n            return (lastPayerUpdate <= block.timestamp);\n        }\n\n        \/\/ If invalid LlamaPay address passed in, test will still pass\n        return true;\n    }\n\n    \/*****************************************************\n     * ================ USER INTERFACE ================= *\n     *****************************************************\/\n\n    \/\/\/ @notice Sets the payer address for the Ante Test to check\n    \/\/\/ @param  _payerAddress address of payer to check\n    function setPayerAddress(address _payerAddress) external {\n        \/\/ Could check that valid payer mapping exists, but also, an invalid\n        \/\/ payer address doesn't fail the test so no risk of false positive.\n        payerAddress = _payerAddress;\n    }\n\n    \/\/\/ @notice Sets the token address of the LlamaPay instance to check\n    \/\/\/ @param  _tokenAddress address of token to check LlamaPay instance for\n    function setTokenAddress(address _tokenAddress) external {\n        \/\/ Check that LlamaPay instance exists for the token\n        (address predictedAddress, bool isDeployed) = factory.getLlamaPayContractByToken(_tokenAddress);\n        require(isDeployed, \"ANTE: LlamaPay instance not deployed for that token\");\n        testedContracts[1] = predictedAddress;\n        tokenAddress = _tokenAddress;\n    }\n} END"}
{"prompt":"Checks WETH9 issued WETH fully backed by ETH\n\nContract to be tested:\npragma solidity ^0.4.18;\n\ncontract WETH9 {\n    string public name     = \"Wrapped Ether\";\n    string public symbol   = \"WETH\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n\n    function() public payable {\n        deposit();\n    }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        Deposit(msg.sender, msg.value);\n    }\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        msg.sender.transfer(wad);\n        Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return this.balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        Transfer(src, dst, wad);\n\n        return true;\n    }\n}","completion":" GPL-3.0-only\n\n\/\/ ┏━━━┓━━━━━┏┓━━━━━━━━━┏━━━┓━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ┃┏━┓┃━━━━┏┛┗┓━━━━━━━━┃┏━━┛━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ┃┗━┛┃┏━┓━┗┓┏┛┏━━┓━━━━┃┗━━┓┏┓┏━┓━┏━━┓━┏━┓━┏━━┓┏━━┓\n\/\/ ┃┏━┓┃┃┏┓┓━┃┃━┃┏┓┃━━━━┃┏━━┛┣┫┃┏┓┓┗━┓┃━┃┏┓┓┃┏━┛┃┏┓┃\n\/\/ ┃┃ ┃┃┃┃┃┃━┃┗┓┃┃━┫━┏┓━┃┃━━━┃┃┃┃┃┃┃┗┛┗┓┃┃┃┃┃┗━┓┃┃━┫\n\/\/ ┗┛ ┗┛┗┛┗┛━┗━┛┗━━┛━┗┛━┗┛━━━┗┛┗┛┗┛┗━━━┛┗┛┗┛┗━━┛┗━━┛\n\/\/ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\/\/ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin\/contracts\/token\/ERC20\/IERC20.sol\";\nimport \"..\/AnteTest.sol\";\n\n\/\/\/ @title WETH9 issued fully backed by ETH test\n\/\/\/ @notice Ante Test to check WETH9 minted WETH matches deposited ETH in contract\ncontract AnteWETH9Test is AnteTest(\"Checks WETH9 issued WETH fully backed by ETH\") {\n    \/\/ https:\/\/etherscan.io\/address\/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n    address public immutable wETH9Addr;\n\n    IERC20 public wETH9Token;\n\n    \/\/\/ @param _wETH9Addr WETH9 contract address (0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 on mainnet)\n    constructor(address _wETH9Addr) {\n        wETH9Addr = _wETH9Addr;\n        wETH9Token = IERC20(_wETH9Addr);\n\n        protocolName = \"WETH9\";\n        testedContracts = [_wETH9Addr];\n    }\n\n    \/\/\/ @notice test to check WETH token supply against contract balance\n    \/\/\/ @return true if WETH9 token supply equals contract balance\n    function checkTestPasses() external view override returns (bool) {\n        return address(wETH9Token).balance == wETH9Token.totalSupply();\n    }\n} END"}
